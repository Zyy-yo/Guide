```python
'''
时间序列 - 索引及切片

TimeSeries是Series的一个子类，所以Series索引及数据选取方面的方法基本一样

同时TimeSeries通过时间序列有更便捷的方法做索引和切片
 
'''
```




    '\n时间序列 - 索引及切片\n\nTimeSeries是Series的一个子类，所以Series索引及数据选取方面的方法基本一样\n\n同时TimeSeries通过时间序列有更便捷的方法做索引和切片\n \n'




```python
# 索引和切片   方法也适用于dateframe

from datetime import datetime
import numpy as np
import pandas as pd

r = pd.date_range('2018.1','2018.3')           # 日期范围，默认freq=D
ts = pd.Series(np.random.rand(len(r)), index=r)
print(ts.head())

print(ts[0], type(ts[0]))          # 下标位置索引，单个索引输出value
print(ts[:3], type(ts[:3]))                # 切片，输出Series
print(ts[:6:2])
print('-'*50)

print(ts['20180110'])               # 时间序列标签索引，支持各种时间字符串，以及datetime格式时间查询
print(ts['2018.01.10'])
print(ts['1/10/2018'])
print(ts[datetime(2018,1,10)])
print(ts['20180110':'20180113'])        # 可以切片，和Series按照index索引原理一样，也是末端包含
print('-'*50)

r2 = pd.date_range('2018.1','2018.3',freq='12H')
ts2 = pd.Series(np.random.rand(len(r2)), index=r2)
print(ts2['2018.1.10'])                 # 直接提取出这个日期的切片范围
```

    2018-01-01    0.892402
    2018-01-02    0.590344
    2018-01-03    0.521168
    2018-01-04    0.782370
    2018-01-05    0.128647
    Freq: D, dtype: float64
    0.8924024731505424 <class 'numpy.float64'>
    2018-01-01    0.892402
    2018-01-02    0.590344
    2018-01-03    0.521168
    Freq: D, dtype: float64 <class 'pandas.core.series.Series'>
    2018-01-01    0.892402
    2018-01-03    0.521168
    2018-01-05    0.128647
    Freq: 2D, dtype: float64
    --------------------------------------------------
    0.43883116316221427
    0.43883116316221427
    0.43883116316221427
    0.43883116316221427
    2018-01-10    0.438831
    2018-01-11    0.140483
    2018-01-12    0.525723
    2018-01-13    0.319742
    Freq: D, dtype: float64
    --------------------------------------------------
    2018-01-10 00:00:00    0.235096
    2018-01-10 12:00:00    0.979670
    Freq: 12H, dtype: float64
    


```python
# 重复索引的时间序列

date = pd.DatetimeIndex(['1/1/2015','1/2/2015','1/3/2015','1/4/2015','1/1/2015','1/2/2015'])
ts = pd.Series(np.random.rand(6), index=date)

print(ts)
print(ts.is_unique, ts.index.is_unique)  # is_unique属性检查是否是唯一，可以检查index，也可以检查values
print('-'*50)

print(ts['20150102'])      # index重复，返回Series，返回这个索引下的所有值
print(ts['20150103'])     # 即使只有单个数据，也会返回Series


ts1 = ts.groupby(level=0).mean()   
       # 通过groupby()分组，参数必须要写一个by=  或level=.分组后得到一个SeriesGroupBy的对象。
    # 重复index的值，这里用平均值处理，就可以得到一个新的时间序列
print(ts1)

```

    2015-01-01    0.289272
    2015-01-02    0.820561
    2015-01-03    0.509115
    2015-01-04    0.515334
    2015-01-01    0.867391
    2015-01-02    0.295461
    dtype: float64
    True False
    --------------------------------------------------
    2015-01-02    0.820561
    2015-01-02    0.295461
    dtype: float64
    2015-01-03    0.509115
    dtype: float64
    2015-01-01    0.578331
    2015-01-02    0.558011
    2015-01-03    0.509115
    2015-01-04    0.515334
    dtype: float64
    


```python
# 作业
# 如图创建时间序列(10*3，值为0-100的随机数)，通过索引得到以下值
# ① 索引得到前4行的所有值
# ② 索引得到2017-12-4 12:00:00的数据
# ③ 索引得到2017-12-4 - 2017-12-5的数据

r = pd.date_range('2017.12', periods=10, freq='12H')
df = pd.DataFrame(np.random.rand(10,3)*100, index=r, 
                  columns=['value1','value2','value3'])
print(df)

print(df.iloc[:4])          # 索引得到前4行的所有值

print(df.loc['2017-12-4 12:00:00'])  # 得到2017-12-4 12:00:00的数据, 此处无法直接用时间序列索引的方法得到，可以用.loc[]行标签索引方法

print(df['2017.12.4':'2017.12.5'])     # 索引得到2017-12-4 - 2017-12-5的数据
```

                            value1     value2     value3
    2017-12-01 00:00:00  15.940298  23.803015  70.913355
    2017-12-01 12:00:00  76.288255  19.841923  10.388595
    2017-12-02 00:00:00  37.905965  30.736028  44.864583
    2017-12-02 12:00:00  68.375018  65.529658  84.299782
    2017-12-03 00:00:00  16.113088  77.817084  42.660517
    2017-12-03 12:00:00  70.862090   7.194881  68.569803
    2017-12-04 00:00:00  38.712122  26.976019  65.095955
    2017-12-04 12:00:00  24.551821  68.153572  12.724885
    2017-12-05 00:00:00  63.099737   5.574530  15.128586
    2017-12-05 12:00:00  19.233445  16.877744  39.708297
                            value1     value2     value3
    2017-12-01 00:00:00  15.940298  23.803015  70.913355
    2017-12-01 12:00:00  76.288255  19.841923  10.388595
    2017-12-02 00:00:00  37.905965  30.736028  44.864583
    2017-12-02 12:00:00  68.375018  65.529658  84.299782
    value1    24.551821
    value2    68.153572
    value3    12.724885
    Name: 2017-12-04 12:00:00, dtype: float64
                            value1     value2     value3
    2017-12-04 00:00:00  38.712122  26.976019  65.095955
    2017-12-04 12:00:00  24.551821  68.153572  12.724885
    2017-12-05 00:00:00  63.099737   5.574530  15.128586
    2017-12-05 12:00:00  19.233445  16.877744  39.708297
    


```python
'''
时间序列 - 重采样

将时间序列从一个频率转换为另一个频率的过程，且会有数据的结合

降采样：高频数据 → 低频数据，eg.以天为频率的数据转为以月为频率的数据
升采样：低频数据 → 高频数据，eg.以年为频率的数据转为以月为频率的数据
 
'''
```


```python
# 重采样    .resample()
# 创建一个以天为频率的时间序列，重采样为按2天为频率

r = pd.date_range('20180101', periods=12)
ts = pd.Series(np.arange(12), index=r)
print(ts)

ts_re = ts.resample('5D')        # 采样，以5天为一个频率，得到一个重采样构建器
ts_re2 = ts.resample('5D').sum()    # 得到一个新的聚合后的Series，聚合方式是求和
print(ts_re, type(ts_re))
print(ts_re2, type(ts_re2))
print('-'*50)

print(ts.resample('5D').mean(), '→ 平均值\n')
print(ts.resample('5D').max(), '→ 最大值\n')
print(ts.resample('5D').min(), '→ 最小值\n')
print(ts.resample('5D').median(), '→ 中位数\n')
print(ts.resample('5D').first(), '→ 返回第一个值\n')
print(ts.resample('5D').last(), '→ 返回最后一个值\n')
print(ts.resample('5D').ohlc(), '→ OHLC重采样\n')
    # OHLC:金融领域的时间序列聚合方式 → open开盘、high最大值、low最小值、close收盘
```

    2018-01-01     0
    2018-01-02     1
    2018-01-03     2
    2018-01-04     3
    2018-01-05     4
    2018-01-06     5
    2018-01-07     6
    2018-01-08     7
    2018-01-09     8
    2018-01-10     9
    2018-01-11    10
    2018-01-12    11
    Freq: D, dtype: int32
    DatetimeIndexResampler [freq=<5 * Days>, axis=0, closed=left, label=left, convention=start, base=0] <class 'pandas.core.resample.DatetimeIndexResampler'>
    2018-01-01    10
    2018-01-06    35
    2018-01-11    21
    Freq: 5D, dtype: int32 <class 'pandas.core.series.Series'>
    --------------------------------------------------
    2018-01-01     2.0
    2018-01-06     7.0
    2018-01-11    10.5
    Freq: 5D, dtype: float64 → 平均值
    
    2018-01-01     4
    2018-01-06     9
    2018-01-11    11
    Freq: 5D, dtype: int32 → 最大值
    
    2018-01-01     0
    2018-01-06     5
    2018-01-11    10
    Freq: 5D, dtype: int32 → 最小值
    
    2018-01-01     2.0
    2018-01-06     7.0
    2018-01-11    10.5
    Freq: 5D, dtype: float64 → 中位数
    
    2018-01-01     0
    2018-01-06     5
    2018-01-11    10
    Freq: 5D, dtype: int32 → 返回第一个值
    
    2018-01-01     4
    2018-01-06     9
    2018-01-11    11
    Freq: 5D, dtype: int32 → 返回最后一个值
    
                open  high  low  close
    2018-01-01     0     4    0      4
    2018-01-06     5     9    5      9
    2018-01-11    10    11   10     11 → OHLC重采样
    
    


```python
#  降采样

r = pd.date_range('20170110', periods=12)
ts = pd.Series(np.arange(1,13), index=r)
print(ts)
print('-'*50)

print(ts.resample('5D').sum())            # 默认 左闭右闭
print(ts.resample('5D', closed='left').sum())  
print(ts.resample('5D', closed='right').sum())          

 # closed：各时间段哪一端是闭合（即包含）的，默认 左闭右闭，可以理解为样本怎么框起来
# values从1到12，按照5D为频率进行重采样：[1,2,3,4,5],[6,7,8,9,10],[11,12]
# closed='left',指定间隔左边为结束： [1,2,3,4,5],[6,7,8,9,10],[11,12]
# closed='right',指定间隔右边为结束：[1],[2,3,4,5,6],[7,8,9,10,11],[12]
'''
思考了一下关于closed导致的采样问题，终于理解了：
首先按照5天来采样，所以先把时间序列做个划分，10日到14日；15日到19日；20日到21日（这里因为数据没有了，所以到21日截止）
时间点为：10日  15日  20日
left:  指定左边为结束，左闭右开，10日对应数值1，包含1在内的后面5个[1,2,3,4,5]求和归到10日，15日对应数值6，包含6在内的
    后面5个[6,7,8,9,10]求和归到15日；20日对应11，包含11在内的[11,12]求和归到20日
right：指定右边为结束，左开右闭，10日对应数值1，不包含在内，而1对于前面的来说属于右边，所以自成一行，自动生成了5日的时间；
    而它后边的5个[2,3,4,5,6]求和归到10日；同理，[7,8,9,10,11]求和归到15日；[12]归到20日
'''

print(ts.resample('5D', label='left').sum())
print(ts.resample('5D', label='right').sum())
# label:聚合值的index， 默认为取左left
```

    2017-01-10     1
    2017-01-11     2
    2017-01-12     3
    2017-01-13     4
    2017-01-14     5
    2017-01-15     6
    2017-01-16     7
    2017-01-17     8
    2017-01-18     9
    2017-01-19    10
    2017-01-20    11
    2017-01-21    12
    Freq: D, dtype: int32
    --------------------------------------------------
    2017-01-10    15
    2017-01-15    40
    2017-01-20    23
    Freq: 5D, dtype: int32
    2017-01-10    15
    2017-01-15    40
    2017-01-20    23
    Freq: 5D, dtype: int32
    2017-01-05     1
    2017-01-10    20
    2017-01-15    45
    2017-01-20    12
    Freq: 5D, dtype: int32
    2017-01-10    15
    2017-01-15    40
    2017-01-20    23
    Freq: 5D, dtype: int32
    2017-01-15    15
    2017-01-20    40
    2017-01-25    23
    Freq: 5D, dtype: int32
    


```python
# 升采样及插值

r = pd.date_range('2017/1/1 0:0:0', periods=5, freq='H')
ts = pd.DataFrame(np.arange(15).reshape(5,3),
                 index=r,
                 columns=['a','b','c'])
print(ts)

print(ts.resample('30T').asfreq())   # .asfreq()  不做填充，返回NaN
print(ts.resample('30T').ffill())   # 向上填充
print(ts.resample('30T').bfill())   # 向下填充

```

                          a   b   c
    2017-01-01 00:00:00   0   1   2
    2017-01-01 01:00:00   3   4   5
    2017-01-01 02:00:00   6   7   8
    2017-01-01 03:00:00   9  10  11
    2017-01-01 04:00:00  12  13  14
                            a     b     c
    2017-01-01 00:00:00   0.0   1.0   2.0
    2017-01-01 00:30:00   NaN   NaN   NaN
    2017-01-01 01:00:00   3.0   4.0   5.0
    2017-01-01 01:30:00   NaN   NaN   NaN
    2017-01-01 02:00:00   6.0   7.0   8.0
    2017-01-01 02:30:00   NaN   NaN   NaN
    2017-01-01 03:00:00   9.0  10.0  11.0
    2017-01-01 03:30:00   NaN   NaN   NaN
    2017-01-01 04:00:00  12.0  13.0  14.0
                          a   b   c
    2017-01-01 00:00:00   0   1   2
    2017-01-01 00:30:00   0   1   2
    2017-01-01 01:00:00   3   4   5
    2017-01-01 01:30:00   3   4   5
    2017-01-01 02:00:00   6   7   8
    2017-01-01 02:30:00   6   7   8
    2017-01-01 03:00:00   9  10  11
    2017-01-01 03:30:00   9  10  11
    2017-01-01 04:00:00  12  13  14
                          a   b   c
    2017-01-01 00:00:00   0   1   2
    2017-01-01 00:30:00   3   4   5
    2017-01-01 01:00:00   3   4   5
    2017-01-01 01:30:00   6   7   8
    2017-01-01 02:00:00   6   7   8
    2017-01-01 02:30:00   9  10  11
    2017-01-01 03:00:00   9  10  11
    2017-01-01 03:30:00  12  13  14
    2017-01-01 04:00:00  12  13  14
    


```python
# 时期重采样   - period

r = pd.period_range('2015','2016',freq='M')
ts = pd.Series(np.arange(len(r)), index=r)
print(ts)

print(ts.resample('3M').asfreq())   # 降采样, 这有个问题，只能显示出来，但不能做值的处理
print(ts.resample('15D').ffill())   # 升采样

# 上面降采样如果做求和或其他计算的聚合，就会报错，应该是3.7的版本不再支持这种做法了：
# Frequency <MonthEnd> cannot be resampled to <3 * MonthEnds>, as they are not sub or super periods
# 解决方法：将periodindex转换为datetimeindex:

ts1 = ts.to_timestamp()
print(ts1.resample('3M').sum())
```

    2015-01     0
    2015-02     1
    2015-03     2
    2015-04     3
    2015-05     4
    2015-06     5
    2015-07     6
    2015-08     7
    2015-09     8
    2015-10     9
    2015-11    10
    2015-12    11
    2016-01    12
    Freq: M, dtype: int32
    2015-01     0
    2015-04     3
    2015-07     6
    2015-10     9
    2016-01    12
    Freq: 3M, dtype: int32
    2015-01-01     0
    2015-01-16     0
    2015-01-31     0
    2015-02-15     1
    2015-03-02     2
    2015-03-17     2
    2015-04-01     3
    2015-04-16     3
    2015-05-01     4
    2015-05-16     4
    2015-05-31     4
    2015-06-15     5
    2015-06-30     5
    2015-07-15     6
    2015-07-30     6
    2015-08-14     7
    2015-08-29     7
    2015-09-13     8
    2015-09-28     8
    2015-10-13     9
    2015-10-28     9
    2015-11-12    10
    2015-11-27    10
    2015-12-12    11
    2015-12-27    11
    2016-01-11    12
    2016-01-26    12
    Freq: 15D, dtype: int32
    2015-01-31     0
    2015-04-30     6
    2015-07-31    15
    2015-10-31    24
    2016-01-31    33
    Freq: 3M, dtype: int32
    


```python
# 作业
# 按要求创建时间序列ts1，通过降采样和升采样，转换成ts2，ts3

r = pd.date_range('20170101', periods=10)
ts1 = pd.Series(np.random.rand(len(r)), index=r)
print(ts1)

print('降采样\n{}'.format(ts1.resample('3D').mean()))
print('升采样\n{}'.format(ts1.resample('12H').ffill()))
```

    2017-01-01    0.517603
    2017-01-02    0.245611
    2017-01-03    0.055147
    2017-01-04    0.468581
    2017-01-05    0.468229
    2017-01-06    0.890516
    2017-01-07    0.475648
    2017-01-08    0.435874
    2017-01-09    0.455822
    2017-01-10    0.660860
    Freq: D, dtype: float64
    降采样
    2017-01-01    0.272787
    2017-01-04    0.609108
    2017-01-07    0.455781
    2017-01-10    0.660860
    Freq: 3D, dtype: float64
    升采样
    2017-01-01 00:00:00    0.517603
    2017-01-01 12:00:00    0.517603
    2017-01-02 00:00:00    0.245611
    2017-01-02 12:00:00    0.245611
    2017-01-03 00:00:00    0.055147
    2017-01-03 12:00:00    0.055147
    2017-01-04 00:00:00    0.468581
    2017-01-04 12:00:00    0.468581
    2017-01-05 00:00:00    0.468229
    2017-01-05 12:00:00    0.468229
    2017-01-06 00:00:00    0.890516
    2017-01-06 12:00:00    0.890516
    2017-01-07 00:00:00    0.475648
    2017-01-07 12:00:00    0.475648
    2017-01-08 00:00:00    0.435874
    2017-01-08 12:00:00    0.435874
    2017-01-09 00:00:00    0.455822
    2017-01-09 12:00:00    0.455822
    2017-01-10 00:00:00    0.660860
    Freq: 12H, dtype: float64
    
