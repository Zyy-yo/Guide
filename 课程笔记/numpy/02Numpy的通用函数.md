```python
# 数组形状： .T       .reshape()      .resize()
import numpy as np

a1 = np.arange(10)
a2 = np.ones((5,2))
print(a1,'\n',a1.T)          # .T 属性, 转置，shape为(3,4)转为(4,3);(3,4,2)转为(2,4,3)
print('-'*20)
print(a2,'\n',a2.T)

print('-'*20)
a3 = np.array([[1,2,3],[4,5,6]])
print(a3, a3.shape)
print(a3.T, a3.T.shape)

print('='*50)

a4 = a1.reshape(2,5)           # 改变已有数组的形状,返回新数组
print(a4)
print('-'*20)

a5 = np.zeros(20).reshape(2,2,5)      # 生成数组时使用reshape()方法改变形状
print(a5)
print('-'*20)

a6 = np.reshape(np.arange(12),(3,4))     # 直接用该方法创建数组，参数里添加数组和目标形状
print(a6)
print('-'*20)
'''
numpy.reshape(a, newshape, order='C')：为数组提供新形状，而不更改其数据，所以元素数量需要一致！！
'''

a7 = np.resize(np.arange(5),(3,4))   # 参数是数组和形状，此时数组元素是5个，而形状的个数是12个，此时从指定的数组里自动填充元素
print(a7)
print('-'*20)

a8 = np.ones(12)
a8.resize(2,5)            # 改变原有数组的大小，就地操作，不返回新的数组。
print(a8)
print('-'*20)

a9 = np.arange(10)
a9.resize(2,6)            # 和reshape()不同，resize()改变时数组元素可以大于原数组，此时，缺失的元素被填充为0
print(a9)

a10 = np.zeros(10).resize(2,5)             # 不能这样使用
print(a10)
'''
numpy.resize(a, new_shape)：返回具有指定形状的新数组
'''

'''
reshape() 和resize()的区别：
1）reshape()只改变形状，不改变大小。因此元素总数不能变。
   resize()改变为指定形状，但是可以改变大小。当变大时，自动根据需要填充元素
   
2）当已有数组时，根据二者函数的定义，都可以传入数组参数和形状来创建函数，见a6和a7，此时二者都生成新数组并返回
   当已有数组.方法，reshape()不改变原有数组，而是返回新的数组；resize()就地操作，改变原数组，不返回新数组。见a4和a8/a9
   对于reshape()在生成数组时直接使用的方法，见a5，resize()只能返回None。
   
   因此，二者在使用时，reshape()可以有三种方式，而resize()只有两种
'''
```

    [0 1 2 3 4 5 6 7 8 9] 
     [0 1 2 3 4 5 6 7 8 9]
    --------------------
    [[1. 1.]
     [1. 1.]
     [1. 1.]
     [1. 1.]
     [1. 1.]] 
     [[1. 1. 1. 1. 1.]
     [1. 1. 1. 1. 1.]]
    --------------------
    [[1 2 3]
     [4 5 6]] (2, 3)
    [[1 4]
     [2 5]
     [3 6]] (3, 2)
    ==================================================
    [[0 1 2 3 4]
     [5 6 7 8 9]]
    --------------------
    [[[0. 0. 0. 0. 0.]
      [0. 0. 0. 0. 0.]]
    
     [[0. 0. 0. 0. 0.]
      [0. 0. 0. 0. 0.]]]
    --------------------
    [[ 0  1  2  3]
     [ 4  5  6  7]
     [ 8  9 10 11]]
    --------------------
    [[0 1 2 3]
     [4 0 1 2]
     [3 4 0 1]]
    --------------------
    [[1. 1. 1. 1. 1.]
     [1. 1. 1. 1. 1.]]
    --------------------
    [[0 1 2 3 4 5]
     [6 7 8 9 0 0]]
    None
    




    '\nreshape() 和resize()的区别：\n1）reshape()只改变形状，不改变大小。因此元素总数不能变。\n   resize()改变为指定形状，但是可以改变大小。当变大时，自动根据需要填充元素\n   \n2）当已有数组时，根据二者函数的定义，都可以传入数组参数和形状来创建函数，见a6和a7，此时二者都生成新数组并返回\n   当已有数组.方法，reshape()不改变原有数组，而是返回新的数组；resize()就地操作，改变原数组，不返回新数组。见a4和a8/a9\n   对于reshape()在生成数组时直接使用的方法，见a5，resize()只能返回None。\n   \n   因此，二者在使用时，reshape()可以有三种方式，而resize()只有两种\n'




```python
# 数组的复制

b1 = np.arange(10)
b2 = b1
print(b2 is b1)
b1[3] = 100             # 数组也是由索引来指向值，因此改变一个，另外一个也改变
print(b1,b2)

b3 = b1.copy()          # .copy()复制，生成数组及其数据的完整拷贝
print(b3 is b1)
b3[0] = 299
print(b1, b3)
```

    True
    [  0   1   2 100   4   5   6   7   8   9] [  0   1   2 100   4   5   6   7   8   9]
    False
    [  0   1   2 100   4   5   6   7   8   9] [299   1   2 100   4   5   6   7   8   9]
    


```python
# 数组类型转换：  .astype()

c1 = np.arange(10, dtype=float)
print(c1)

c2 = c1.astype(np.int)           # 数组.astype(), 不是numpy.astype()
print(c2)

'''
a.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)
'''
# 注意：养成好习惯，数组类型用np.int/int32，而不是直接int/int32
```

    [0. 1. 2. 3. 4. 5. 6. 7. 8. 9.]
    [0 1 2 3 4 5 6 7 8 9]
    




    "\na.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)\n"




```python
# 数组堆叠   水平堆叠hstack    
a = np.arange(5)
b = np.arange(5,9)
ar1 = np.hstack((a,b))
print(ar1, ar1.shape)

a2 = np.array([[1,2],[3,4],[5,6]])
b2 = np.array([['a','b'],['c','d'],['e','f']])
ar2 = np.hstack((a2,b2))
print(ar2,ar2.shape)

a3 = np.array([[1,2,3],[4,5,6]])
b3 = np.array([[100],[200]])
ar3 = np.hstack((a3,b3))
print(ar3,ar3.shape)

'''
numpy.hstack((a,b)),hstack是水平堆叠数组，对于一维数组，两个数组的大小可以不一样,a数组(n,),b数组(m,)，堆叠后的新数组shape为(n+m,)；
对于二维数组，两个数组在形状上必须保持行数一致。a数组(n,m1),b数组(n,m2),numpy.hstack((a,b))堆叠后的新数组shape为(n,m1+m2)
numpy.hstack((a,b,c...))里面的数组可以有多个，原理一样

'''
```

    [0 1 2 3 4 5 6 7 8] (9,)
    [['1' '2' 'a' 'b']
     ['3' '4' 'c' 'd']
     ['5' '6' 'e' 'f']] (3, 4)
    [[  1   2   3 100]
     [  4   5   6 200]] (2, 4)
    




    '\nnumpy.hstack((a,b)),hstack是水平堆叠数组，对于一维数组，两个数组的大小可以不一样；对于二维数组，两个数组在形状上必须保持行数一致。\n'




```python
# 数组堆叠    垂直堆叠vstack

a = np.arange(5)
b = np.arange(4,9)
ar1 = np.vstack((a,b))
print(ar1,ar1.shape)

a2 = np.array([[1,2],[3,4]])
b2 = np.array([['a','b'],['c','d'],['e','f']])
ar2 = np.vstack((a2,b2))
print(ar2,ar2.shape)

'''
numpy.vstack((a,b)),vstack是垂直堆叠数组，对于一维数组，两个数组的大小必须一致，a数组(n,),b数组(n,),堆叠后组成二维数组shape为(2,n)；
对于二维数组，两个数组在形状上必须保持列数一致。a数组(n1,m),b数组(n2,m),numpy.hstack((a,b))堆叠后的新数组shape为(n1+n2,m)
numpy.vstack((a,b,c...))里面的数组可以有多个，原理一样

'''
```

    [[0 1 2 3 4]
     [4 5 6 7 8]] (2, 5)
    [['1' '2']
     ['3' '4']
     ['a' 'b']
     ['c' 'd']
     ['e' 'f']] (5, 2)
    




    '\nnumpy.vstack((a,b)),vstack是垂直堆叠数组，对于一维数组，两个数组的大小必须一致，a数组(n,),b数组(n,),堆叠后组成二维数组shape为(2,n)；\n对于二维数组，两个数组在形状上必须保持列数一致。a数组(n1,m),b数组(n2,m),numpy.hstack((a,b))堆叠后的新数组shape为(n1+n2,m)\n'




```python
# 数组堆叠  stack()  沿轴0或轴1堆叠

a = np.arange(5)
b = np.arange(5,10)
ar1 = np.stack((a,b))           # 默认axis=0，此时(n,)(n,)组成新的二维数组(2,n)
ar2 = np.stack((a,b),axis=1)    # axis=1,此时两个一维数组(n,)(n,)组成新的二维数组(n,2)
c = np.arange(10,15)
ar3 = np.stack((a,b,c),axis=1)   # 三个一维数组(n,)(n,)(n,)组成新的二维数组(n,3)

print(a,a.shape)
print(b,b.shape)
print(ar1,ar1.shape)
print(ar2,ar2.shape)
print(ar3,ar3.shape)

'''
numpy.stack()方法总结：
1）它是沿新的轴连接数组的序列；一维数组连接成二维数组；二维数组连接成三维数组
1）可以连接多个数组，默认axis=0，此时是将每个数组整体作为新的数组的一个元素，见ar1和ar4。若a和b沿新轴0生成新数组c，那么c[0]为a，c[1]为b。
2）axis=1，此时是将每个数组中索引对应的元素组成数组，作为新数组的元素。见ar2/ar3和ar5。以二维数组为例，a [[1 2] [3 4]] 和b [[5 6] [7 8]]
    a[0]=[1 2],b[0]=[5 6] 组成c[0] [[1 2] [5 6]],a[1]=[3 4],b[1]=[7 8],组成c[1] [[3 4],[7 8]],则c为三维数组 [[[1 2] [5 6]] [[3 4] [7 8]]]
3）数组形状必须相同

'''
print('-'*50)
a = np.array([[1,2,3],[4,5,6]])
b = np.array([['a','b','c'],['d','e','f']])
ar4 = np.stack((a,b))
ar5 = np.stack((a,b),axis=1)
print(ar4,ar4.shape)
print(ar5,ar5.shape)


```

    [0 1 2 3 4] (5,)
    [5 6 7 8 9] (5,)
    [[0 1 2 3 4]
     [5 6 7 8 9]] (2, 5)
    [[0 5]
     [1 6]
     [2 7]
     [3 8]
     [4 9]] (5, 2)
    [[ 0  5 10]
     [ 1  6 11]
     [ 2  7 12]
     [ 3  8 13]
     [ 4  9 14]] (5, 3)
    --------------------------------------------------
    [[['1' '2' '3']
      ['4' '5' '6']]
    
     [['a' 'b' 'c']
      ['d' 'e' 'f']]] (2, 2, 3)
    [[['1' '2' '3']
      ['a' 'b' 'c']]
    
     [['4' '5' '6']
      ['d' 'e' 'f']]] (2, 2, 3)
    


```python
# 数组拆分      hsplit(ary, indices_or_sections)  水平拆分
a1 = np.arange(12).reshape(3,4)
a2 = np.hsplit(a1,2)
print(a1)
print('-'*20)

a3 = np.arange(10)
a4 = np.hsplit(a3,5)
print(a4, type(a4))
print(a4[0],a4[1],sep='\n\n')
print('-'*20)

print(a2[0],'\n\n',a2[1],type(a2))
print('-'*50)
'''
numpy.hsplit()  将数组水平拆分为多个子数组，第一个参数是数组，第二个参数是拆分的个数。返回列表,列表中元素为数组。

要拆分的个数必须能够被列数整除  →  如3行4列，拆分成2个，前2列为一个数组，后2列为一个数组
'''
```

    [[ 0  1  2  3]
     [ 4  5  6  7]
     [ 8  9 10 11]]
    --------------------
    [array([0, 1]), array([2, 3]), array([4, 5]), array([6, 7]), array([8, 9])] <class 'list'>
    [0 1]
    
    [2 3]
    --------------------
    [[0 1]
     [4 5]
     [8 9]] 
    
     [[ 2  3]
     [ 6  7]
     [10 11]] <class 'list'>
    --------------------------------------------------
    




    '\nnumpy.hsplit()  将数组水平拆分为多个子数组，第一个参数是数组，第二个参数是拆分的个数。返回列表,列表中元素为数组。\n\n要拆分的个数必须能够被列数整除\n'




```python
# 数组拆分      vsplit(ary, indices_or_sections)  垂直拆分

a1 = np.arange(12).reshape(4,3)

b1 = np.vsplit(a1,2)

print(a1, b1, b1[0], b1[1], type(b1), sep='\n\n')
print('-'*50)

'''
vsplit(ary, indices_or_sections)  垂直拆分，返回列表，列表中的元素为数组。

要拆分的个数必须能够被行数整除  →  如4行3列，拆分为2个，则前2行为一个数组，后两行为一个数组

无法拆分一维数组。

对于三维数组： vsplit拆分时按照里面的二维数组个数拆分，shape(2,3,5) 有2个3行5列的二维数组，可以拆分为2个，每个的shape为(1,3,5)
'''

a2 = np.arange(30).reshape(2,3,5)
b2 = np.vsplit(a2,2)
print(b2)
print('-'*50)

print(b2[0])
bb = np.hsplit(b2[0],3)
print(b2[0], b2[0].shape,bb)
```

    [[ 0  1  2]
     [ 3  4  5]
     [ 6  7  8]
     [ 9 10 11]]
    
    [array([[0, 1, 2],
           [3, 4, 5]]), array([[ 6,  7,  8],
           [ 9, 10, 11]])]
    
    [[0 1 2]
     [3 4 5]]
    
    [[ 6  7  8]
     [ 9 10 11]]
    
    <class 'list'>
    --------------------------------------------------
    [array([[[ 0,  1,  2,  3,  4],
            [ 5,  6,  7,  8,  9],
            [10, 11, 12, 13, 14]]]), array([[[15, 16, 17, 18, 19],
            [20, 21, 22, 23, 24],
            [25, 26, 27, 28, 29]]])]
    --------------------------------------------------
    [[[ 0  1  2  3  4]
      [ 5  6  7  8  9]
      [10 11 12 13 14]]]
    [[[ 0  1  2  3  4]
      [ 5  6  7  8  9]
      [10 11 12 13 14]]] (1, 3, 5) [array([[[0, 1, 2, 3, 4]]]), array([[[5, 6, 7, 8, 9]]]), array([[[10, 11, 12, 13, 14]]])]
    


```python
# 数组的简单运算

# 与标量的运算
a1 = np.arange(6).reshape(2,3)

print(a1 + 10)                      # 加法
print(a1 * 2)                         # 乘法
print(10 / (a1+1))                  # 除法
print(a1 ** 3)                     # 幂
print(a1)                   # 返回新数组，不改变原数组
print('-'*50)

# 常用函数
print(a1.mean())             # 直接数组.方法
print(a1.max())
print(a1.min())
print(a1.sum())
print(a1.std())
print(a1.var())
print('-'*50)


                                    # numpy.方法，可以设定沿轴，轴为None则展平数组。
a2 = np.arange(20).reshape(2,10)
print(a2)
print(np.amax(a2))              # aixs=None, 展平数组
print(np.amin(a2,1))          # axis = 1, 按行，每行里面的最小值
print(np.median(a2))         # 中位数
print(np.sum(a2,1))
print(np.sort(np.array([10,3,2,105,89,23,109])))           # 排序

```

    [[10 11 12]
     [13 14 15]]
    [[ 0  2  4]
     [ 6  8 10]]
    [[10.          5.          3.33333333]
     [ 2.5         2.          1.66666667]]
    [[  0   1   8]
     [ 27  64 125]]
    [[0 1 2]
     [3 4 5]]
    --------------------------------------------------
    2.5
    5
    0
    15
    1.707825127659933
    2.9166666666666665
    --------------------------------------------------
    [[ 0  1  2  3  4  5  6  7  8  9]
     [10 11 12 13 14 15 16 17 18 19]]
    19
    [ 0 10]
    9.5
    [ 45 145]
    [  2   3  10  23  89 105 109]
    


```python
# 作业
# 1.创建一个20个元素的数组，分别改变成两个形状：(4,5),(5,6) （提示：超出范围用resize）

import numpy as np

a1 = np.arange(20).reshape(4,5)

a2 = np.arange(20)
a3 = np.resize(a2,(5,6))

print(a1, a3, sep='\n\n')

```

    [[ 0  1  2  3  4]
     [ 5  6  7  8  9]
     [10 11 12 13 14]
     [15 16 17 18 19]]
    
    [[ 0  1  2  3  4  5]
     [ 6  7  8  9 10 11]
     [12 13 14 15 16 17]
     [18 19  0  1  2  3]
     [ 4  5  6  7  8  9]]
    


```python
# 2.创建一个(4,4)的数组，把其元素类型改为字符型

b1 = np.arange(16).reshape(4,4)
print(b1,b1.dtype)

b2 = b1.astype(np.str)
print(b2,b2.dtype)
```

    [[ 0  1  2  3]
     [ 4  5  6  7]
     [ 8  9 10 11]
     [12 13 14 15]] int32
    [['0' '1' '2' '3']
     ['4' '5' '6' '7']
     ['8' '9' '10' '11']
     ['12' '13' '14' '15']] <U11
    


```python
# 3. 根据要求创建数组，运用数组的运算方法得到结果：result = ar * 10 +100，并求出result的均值及求和

c1 = np.arange(16).reshape(4,4)
print(c1)

result = c1 * 10 + 100
print(result)

print('result数组的均值：{}'.format(result.mean()))
print('result数组求和：{}'.format(result.sum()))
```

    [[ 0  1  2  3]
     [ 4  5  6  7]
     [ 8  9 10 11]
     [12 13 14 15]]
    [[100 110 120 130]
     [140 150 160 170]
     [180 190 200 210]
     [220 230 240 250]]
    result数组的均值：175.0
    result数组求和：2800
    
