```python
'''
python开源的科学计算工具包

高级数值编程工具：
    强大的N维数组对象：ndarray
    对数组结构数据进行循环（不需要遍历）（矩阵运算）
    随机数、线性代数、博里叶变换等功能

'''
```




    '\npython开源的科学计算工具包\n\n高级数值编程工具：\n    强大的N维数组对象：ndarray\n    对数组结构数据进行循环（不需要遍历）（矩阵运算）\n    随机数、线性代数、博里叶变换等功能\n\n'




```python
'''
Numpy基础数据结构：

NumPy数组是一个多维数组对象，称为ndarray。其由两部分组成：
① 实际的数据
② 描述这些数据的元数据
'''
```




    '\nNumpy基础数据结构：\n\nNumPy数组是一个多维数组对象，称为ndarray。其由两部分组成：\n① 实际的数据\n② 描述这些数据的元数据\n'




```python
# 多维数组
import numpy as np

a = np.array([1,2,3,4,5,6,7])
b = np.array([[1,2,3,4,5,6,7],[3.8,8,2,1,0,3,2]])
print(a, b, sep='\n')          # 输出数组的格式，中括号，元素之间没有逗号（和列表区分）

print(a.ndim, b.ndim)      # 输出数组维度的个数（轴数），或者说‘轶'，维度的数量也称rank

print(a.shape, b.shape)    # 数组的形状,即维度，n行m列。注意一维数组输出的是(m,)列

print(a.size, b.size)     # 数组大小，即元素总数量，对于n行m列的数组，大小为n*m

print(a.dtype, b.dtype)   # 数组中的元素类型，类似type()，注意type()是函数

print(a.itemsize, b.itemsize)  # 数组中元素的字节大小,int32类型字节是4；float64字节是8

print(a.data, b.data)    # 包含实际数组元素的缓冲区，由于一般通过数组的索引获取元素，所以通常不需要使用这个属性。

a       #  在交互方式下输出，会输出array([1,2,3,4,5,6,7]), array(数组)

'''
有趣的是，当更改数组中的一个元素的数据类型时，其他元素也都变成了该类型。测试了一下，其中的优先性：字符串 > 浮点型 > 整型
整型的数组中出现一个浮点型元素，数组所有元素变成浮点型；浮点型数组中出现字符型元素，数组所有元素变成字符串型

type()是函数；np.array() 中 array()是方法；而上面的 .shape等这些不带括号的叫做属性。
'''

'''
数组的基本属性：
（1）数组的维数成为轶（rank），一维数组的秩为1，二维数组的秩为2，以此类推
（2）在NumPy中，每一个线性的数组称为是一个轴（axes），秩其实是描述轴的数量
    # 比如说，二维数组相当于是两个一维数组，其中第一个一维数组中每个元素又是一个一维数组
    # 所以一维数组就是NumPy中的轴（axes），第一个轴相当于是底层数组，第二个轴是底层数组里的数组。
    # 而轴的数量——秩，就是数组的维数。 (can't understand)
'''
```

    [1 2 3 4 5 6 7]
    [[1.  2.  3.  4.  5.  6.  7. ]
     [3.8 8.  2.  1.  0.  3.  2. ]]
    1 2
    (7,) (2, 7)
    7 14
    int32 float64
    4 8
    <memory at 0x09D0A920> <memory at 0x09D374E0>
    




    "\n数组的基本属性：\n（1）数组的维数成为轶（rank），一维数组的秩为1，二维数组的秩为2，以此类推\n（2）在NumPy中，每一个线性的数组称为是一个轴（axes），秩其实是描述轴的数量\n    # 比如说，二维数组相当于是两个一维数组，其中第一个一维数组中每个元素又是一个一维数组\n    # 所以一维数组就是NumPy中的轴（axes），第一个轴相当于是底层数组，第二个轴是底层数组里的数组。\n    # 而轴的数量——秩，就是数组的维数。 (can't understand)\n"




```python
# 创建数组：array()方法，参数可以是列表、元组、数组、生成器等，可以创建多维数组

a1 = np.array(range(10))    # 生成器

a2 = np.array([1,2,3,4.5,6,8])   # 列表

a3 = np.array([[1,2,3],('a','b','c')])   # 二维数组：嵌套序列（列表、元组均可）

a4 = np.array([[1,2,3],('a','b','c','d')])  # 里面嵌套的序列大小不一样，会有什么不同呢？
print(a1, type(a1), a1.dtype)       
print(a2, type(a2), a2.dtype) 
print(a3, type(a3), a3.dtype) 
print(a4, type(a4), a4.dtype)
print('-'*20)

print(a1.ndim, a1.shape, a1.size)
print(a2.ndim, a2.shape, a2.size)
print(a3.ndim, a3.shape, a3.size)    # 二维数组，2行3列，一共6个元素
print(a4.ndim, a4.shape, a4.size)    # 一维数组，里面的列表和元组分别作为一个元素，1行2列，一共2个元素
```

    [0 1 2 3 4 5 6 7 8 9] <class 'numpy.ndarray'> int32
    [1.  2.  3.  4.5 6.  8. ] <class 'numpy.ndarray'> float64
    [['1' '2' '3']
     ['a' 'b' 'c']] <class 'numpy.ndarray'> <U11
    [list([1, 2, 3]) ('a', 'b', 'c', 'd')] <class 'numpy.ndarray'> object
    --------------------
    1 (10,) 10
    1 (6,) 6
    2 (2, 3) 6
    1 (2,) 2
    


```python
# 创建数组：arange()方法，类似range(),但是range()只支持整型，在给定间隔内返回均匀间隔的值。
b = np.arange(10)    # 返回0-9的整型
print(b)

b1 = np.arange(10.0)  #  返回0-9的浮点型
print(b1)

b2 = np.arange(5,13)  # 返回5-12的整型
print(b2)

b3 = np.arange(5.0,13, 2.5)  # 返回5-13的浮点型，步长为2.5
print(b3)

b4 = np.arange(10000)   # 如果数组太大无法打印，Numpy会自动跳过数组的中心部分，只打印边角
print(b4)
```

    [0 1 2 3 4 5 6 7 8 9]
    [0. 1. 2. 3. 4. 5. 6. 7. 8. 9.]
    [ 5  6  7  8  9 10 11 12]
    [ 5.   7.5 10.  12.5]
    [   0    1    2 ... 9997 9998 9999]
    


```python
# 还有一种创建方式
c = np.random.rand(10)
print(c)
c1 = np.random.rand(10).reshape(2,5)   # 将np.random.rand(10)生成的10个元素的一维数组分成2行5列的二维数组
print(c1)
```

    [0.75351381 0.18812609 0.76410503 0.1421719  0.12675104 0.66605965
     0.83534885 0.02950011 0.45891471 0.59736539]
    [[0.31913266 0.83406685 0.56351059 0.31329713 0.83951421]
     [0.51174507 0.5353195  0.20786582 0.70886719 0.64800066]]
    


```python
# 创建数组：linspace()，返回在间隔[开始，停止]上计算的num个均匀间隔的样本

d1 = np.linspace(1,5,5)         # 返回的都是浮点型
d2 = np.linspace(2.0,3.0,num=5,retstep=True)
d3 = np.linspace(1,5,num=5,endpoint=False)
print(d1,type(d1),d1.dtype)
print(d2,type(d2))            # retstep=True时，返回的是元组类型，因此不能用dtype直接来查元素的类型
print(d3,type(d3))
print(d2[0], d2[0].dtype)             # 既然是元组,那么就可以用索引的方式来输出里面的数组,并查数组的dtype
'''
numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)
start：起始值，stop：结束值
num：生成样本数，默认为50
endpoint：如果为真，则包含结束值。默认值为True。
retstep：如果为真，返回（样本,步长） → 输出为一个包含2个元素的元组，第一个元素为array，第二个为步长实际值
'''
```

    [1. 2. 3. 4. 5.] <class 'numpy.ndarray'> float64
    (array([2.  , 2.25, 2.5 , 2.75, 3.  ]), 0.25) <class 'tuple'>
    [1.  1.8 2.6 3.4 4.2] <class 'numpy.ndarray'>
    [2.   2.25 2.5  2.75 3.  ] float64
    




    '\nnumpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)\nstart：起始值，stop：结束值\nnum：生成样本数，默认为50\nendpoint：如果为真，则包含结束值。默认值为True。\nretstep：如果为真，返回（样本,步长） → 输出为一个包含2个元素的元祖，第一个元素为array，第二个为步长实际值\n'




```python
# 创建数组：zeros()   zeros_like()    ones()      ones_like()
e1 = np.zeros(5)   # 返回一个给定形状的元素为0的数组,默认dtype=float
e2 = np.zeros((2,3),dtype=int)    # 二维数组的话，参数是元组类型  (n,m) 表示n行m列，dtype可以设置
print(e1)
print(e2)
'''
numpy.zeros(shape, dtype=float, order='C'):返回给定形状和类型的新数组，用零填充。
shape：数组维度，二维以上需要用()，且输入参数为整数
dtype：数据类型，默认numpy.float64
order：是否在存储器中以C或F(Fortran)连续（按行或列方式）存储多维数据。
'''
print('-'*30)
e3 = np.array([list(range(5)), list(range(5,10))])
e4 = np.zeros_like(e3)    # 返回具有与给定数组相同的形状和类型的数组，元素为0
print(e3, e4, sep='\n')

print('-'*30)
e5 = np.ones((2,5,2))               # 用法和zeros()相同，(2,5,3)三维数组，里面含2个5行3列的二维数组
e6 = np.ones((3,2), dtype=int)
print(e5, e6, sep='\n')

print('-'*30)
e7 = np.ones_like(e3)
print(e7)


```

    [0. 0. 0. 0. 0.]
    [[0 0 0]
     [0 0 0]]
    ------------------------------
    [[0 1 2 3 4]
     [5 6 7 8 9]]
    [[0 0 0 0 0]
     [0 0 0 0 0]]
    ------------------------------
    [[[1. 1.]
      [1. 1.]
      [1. 1.]
      [1. 1.]
      [1. 1.]]
    
     [[1. 1.]
      [1. 1.]
      [1. 1.]
      [1. 1.]
      [1. 1.]]]
    [[1 1]
     [1 1]
     [1 1]]
    ------------------------------
    [[1 1 1 1 1]
     [1 1 1 1 1]]
    


```python
# 创建数组： eye()  只创建二维数组

'''
numpy.eye(n,m=None,k=0,dtype=<class 'float'>,order='C')
1）代数学中，矩阵从左上到右下的数归为主对角线；从左下到右上的数归为副对角线
2）n,m为形状，m默认为None，即numpy.eye(n) 时，m默认和n相同，即创建一个n*n的正方矩阵
3）k 我理解为主对角线的位置，默认为0，即从左上角开始，往右下的对角线。k取正数，表示为上面位置的对角线，负数为下面位置的对角线。
'''
f1 = np.eye(5)              # n=5，m默认为n，也等于5，k默认为0,创建5*5的正方矩阵，左上角开始的对角线值为1，其他元素都是0
print(f1)
print('-'*20)

f2 = np.eye(5,4)         # 5行4列的矩阵，左上角开始的主对角线值为1
print(f2)

print('-'*20)
f3 = np.eye(5,4,k=2)      # 5行4列的矩阵,从左上角往右边的第三个数开始的主对角线值为1 
print(f3)

print('-'*20)
f4 = np.eye(3,5,k=-1)      # 3行5列的矩阵,从左上角往下的第1个数开始的主对角线值为1 
print(f4)
```

    [[1. 0. 0. 0. 0.]
     [0. 1. 0. 0. 0.]
     [0. 0. 1. 0. 0.]
     [0. 0. 0. 1. 0.]
     [0. 0. 0. 0. 1.]]
    --------------------
    [[1. 0. 0. 0.]
     [0. 1. 0. 0.]
     [0. 0. 1. 0.]
     [0. 0. 0. 1.]
     [0. 0. 0. 0.]]
    --------------------
    [[0. 0. 1. 0.]
     [0. 0. 0. 1.]
     [0. 0. 0. 0.]
     [0. 0. 0. 0.]
     [0. 0. 0. 0.]]
    --------------------
    [[0. 0. 0. 0. 0.]
     [1. 0. 0. 0. 0.]
     [0. 1. 0. 0. 0.]]
    

# ndarray的数据类型

bool  用一个字节存储的布尔类型

int   由所在平台决定其大小的整数（一般为int32或int64）

int8  一个字节大小，-128 至 127

int16 整数，-32768 至 32767

int32 整数，-2 ** 31 至 2 ** 32 -1

int64 整数，-2 ** 63 至 2 ** 63 - 1

uint8 无符号整数，0 至 255

uint16 无符号整数，0 至 65535

uint32 无符号整数，0 至 2 ** 32 - 1

uint64 无符号整数，0 至 2 ** 64 - 1

float16 半精度浮点数：16位，正负号1位，指数5位，精度10位

float32 单精度浮点数：32位，正负号1位，指数8位，精度23位

float64或float 双精度浮点数：64位，正负号1位，指数11位，精度52位

complex64 复数，分别用两个32位浮点数表示实部和虚部

complex128或complex 复数，分别用两个64位浮点数表示实部和虚部



```python
# 作业
# 1：分别按照要求，生成一个一维数组、二维数组，并且查看其shape
g = np.array([1,2,'a','hello',[1,2,3],{'two':200, 'one':100}])
print(g, g.shape)

g2 = np.array([range(6),list('abcdef'),
               ['True', 'False', 'True', 'False', 'True', 'True']],
              dtype='U')                                            
print(g2, g2.shape)

'''
dtype='U',字符类型的，后面跟着数字的话表示字节数,如U1即1个字节，那么True只能显示为T，U8的话，能显示出8个字节....
'''
```

    [1 2 'a' 'hello' list([1, 2, 3]) {'two': 200, 'one': 100}] (6,)
    [['0' '1' '2' '3' '4' '5']
     ['a' 'b' 'c' 'd' 'e' 'f']
     ['True' 'False' 'True' 'False' 'True' 'True']] (3, 6)
    




    "\ndtype='U',字符类型的，后面跟着数字的话表示字节数,如U1即1个字节，那么True只能显示为T，U8的话，能显示出8个字节....\n"




```python
# 2：生成一个一维数组，起始值为5，终点值为15，样本数为10个
g3 = np.linspace(5,15,10)
g4 = np.linspace(5,14,10)
print(g3, g4, sep='\n')
```

    [ 5.          6.11111111  7.22222222  8.33333333  9.44444444 10.55555556
     11.66666667 12.77777778 13.88888889 15.        ]
    [ 5.  6.  7.  8.  9. 10. 11. 12. 13. 14.]
    


```python
# 3:按照要求创建以下数组
print(np.zeros((4,4)))

print(np.ones((2,3)))

print(np.eye(3))
```

    [[0. 0. 0. 0.]
     [0. 0. 0. 0.]
     [0. 0. 0. 0.]
     [0. 0. 0. 0.]]
    [[1. 1. 1.]
     [1. 1. 1.]]
    [[1. 0. 0.]
     [0. 1. 0.]
     [0. 0. 1.]]
    
