```python
'''
核心：基本索引及切片

      布尔型索引及切片
'''
```




    '\n核心：基本索引及切片\n\n      布尔型索引及切片\n'




```python
# 基本索引及切片
import numpy as np

   # 一维数组索引和切片
a1 = np.arange(20)
print(a1)
print(a1[3])
print(a1[4:8])          # 左闭右开
print('-'*50)

   # 二维数组索引和切片
a2 = np.arange(12).reshape(3,4)
print(a2,'\n','数组的轴数为：%i'%a2.ndim)
print(a2[0],'数组轴数为：%i'%a2[0].ndim)       # 索引为下一维度的一个元素，所以是一维数组
print(a2[0][2])    # 二次索引，得到一维数组中的一个元素

print(a2[1:3],'数组轴数为：%i'%a2[1:3].ndim)   # 切片为两个一维数组组成的二维数组
print(a2[2,1])           # 双重索引，直接索引到一维数组中的一个元素，[n,m] 索引到n+1行m+1列
print(a2[:2,1:3])        # 双重索引切片，同样左闭右开 [:2,1:3]  切片范围：第1到2行中的第2到3列
print('-'*50)

   # 三维数组索引和切片
a3 = np.arange(16).reshape(2,2,4)
print(a3,'数组的轴数为 %i'%a3.ndim)
print(a3[1],'数组的轴数为 %i'%a3[1].ndim)   # 三维数组的下一维度，二维数组
print(a3[1][0],'数组的轴数为 %i'%a3[1][0].ndim)  # 二次索引
print(a3[1][0][2],'数组的轴数为 %i'%a3[1][0][2].ndim)    # 三次索引

print(a3[1,0])          # 三维数组中第2个元素中的第1个元素（第2个二维数组中的第1个一维数组）
print(a3[1,0,2])       # 同样，也可以直接通过[k,n,m]的形式直接索引到单个元素

print(a3[:2,:2,2:4])   #  切片同样的原理
```

    [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19]
    3
    [4 5 6 7]
    --------------------------------------------------
    [[ 0  1  2  3]
     [ 4  5  6  7]
     [ 8  9 10 11]] 
     数组的轴数为：2
    [0 1 2 3] 数组轴数为：1
    2
    [[ 4  5  6  7]
     [ 8  9 10 11]] 数组轴数为：2
    9
    [[1 2]
     [5 6]]
    --------------------------------------------------
    [[[ 0  1  2  3]
      [ 4  5  6  7]]
    
     [[ 8  9 10 11]
      [12 13 14 15]]] 数组的轴数为 3
    [[ 8  9 10 11]
     [12 13 14 15]] 数组的轴数为 2
    [ 8  9 10 11] 数组的轴数为 1
    10 数组的轴数为 0
    [ 8  9 10 11]
    10
    [[[ 2  3]
      [ 6  7]]
    
     [[10 11]
      [14 15]]]
    


```python
# 布尔型索引和切片

b = np.arange(12).reshape(3,4)
i = np.array([True,False,True])
j = np.array([True,True,False,False])

print(b, b.shape, b.ndim)
print(i,i.dtype)
print(j,j.dtype)

print('-'*30)

print(b[i,:])    # 在第一维度做判断，只保留True，i为[True False True]，[i,:]对应到行（同[i]），第一和第三行为True，因此只打印这两行
print(b[:,j])    # 在第二维度做判断,此时不能写成[j],因为有4列，写成[j]就变成在第一维度了。第一和第二列为True，因此只打印了这两列

   # 布尔型索引，以布尔型的矩阵去做筛选

m = b > 5           # 判断矩阵
print(m)    
print(b[m])         # 用m判断矩阵去筛选b数组中>5的元素  → 重点，pandas中判断方式原理来源于此
```

    [[ 0  1  2  3]
     [ 4  5  6  7]
     [ 8  9 10 11]] (3, 4) 2
    [ True False  True] bool
    [ True  True False False] bool
    ------------------------------
    [[ 0  1  2  3]
     [ 8  9 10 11]]
    [[0 1]
     [4 5]
     [8 9]]
    [[False False False False]
     [False False  True  True]
     [ True  True  True  True]]
    [ 6  7  8  9 10 11]
    


```python
# 数组索引及切片的值更改、复制

a1 = np.arange(10)
print(a1)

a1[5] = 100
a1[6:10] = 200            # 数组可以通过将标量赋值给切片的形式，来改变原始数组
print(a1)

b = a1.copy().astype(np.float)          # 复制，此处将b数组内元素改为浮点型，否则下面赋值只能取整数部分。
b[5:8] = 0.88
print(a1)
print(b)
```

    [0 1 2 3 4 5 6 7 8 9]
    [  0   1   2   3   4 100 200 200 200 200]
    [  0   1   2   3   4 100 200 200 200 200]
    [  0.     1.     2.     3.     4.     0.88   0.88   0.88 200.   200.  ]
    


```python
# 作业
# 1. 按照要求创建数组，通过索引，其ar[4]、ar[:2,3:]、ar[3][2]分别是多少

a = np.arange(25).reshape(5,5)
print(a,'\n')

print(a[4], a[:2,3:], a[3][2], sep='\n\n')

```

    [[ 0  1  2  3  4]
     [ 5  6  7  8  9]
     [10 11 12 13 14]
     [15 16 17 18 19]
     [20 21 22 23 24]] 
    
    [20 21 22 23 24]
    
    [[3 4]
     [8 9]]
    
    17
    


```python
# 2. 按照要求创建数组，筛选出元素值大于5的值并生成新的数组

b = np.arange(10).reshape(2,5)
b1 = b[b>5]
print(b1)
```

    [6 7 8 9]
    
