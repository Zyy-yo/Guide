```python
# 列表的特征

lst = [1, 3.0, 'abc', (3, 0, 2), [1, 'd']]
print(lst[3], type(lst[3]))
    # 可以包含任意类型的对象，数值、字符串、元组、列表
    # 同时又反映了列表的可嵌套性
    
lst[2] = 18.8
lst[3:5] = [20, 19]
print(lst)
    # 可以更改
    
# 另外列表作为序列，具有序列的特性：可以通过下标索引访问；可以做连接和重复
print(lst[4])
print(lst + ['3'])
print(lst * 2)

# 一件有意思的事情
a = [1, 3, [2, 4, ["i'm here", 6, 9], 0, 1], 8]
  # 提取里面的那句话
print(a[2][2][0])
  # 其实就是一层一层的指向，层层剥开
```

    (3, 0, 2) <class 'tuple'>
    [1, 3.0, 18.8, 20, 19]
    19
    [1, 3.0, 18.8, 20, 19, '3']
    [1, 3.0, 18.8, 20, 19, 1, 3.0, 18.8, 20, 19]
    i'm here
    


```python
# 小作业
# 1. [1, 2, 3]和['1','2','3']的区别。很明显所含元素的数据类型不同，前者是数值int型，后者是字符串str型

# 2. 创建一个列表，包含中国的5个城市名称
a = ['上海', '北京', '深圳', '杭州', '武汉']
   # 显然，这里要用到字符串型
    
# 3. 为name = ['小明','小红']增加一个元素'团支书'
name = ['小明','小红']
print(name + ['团支书'])
   # 此处要注意，虽然团支书是字符串类型，但是name是list型，在用+做连接时，只能连接同类型，所以连接的'团支书'也要包含在list型里 
    # 不是在name这个列表本身做的变动，实际上是连接了两个列表并生成了一个新的列表
print(name)
```

    ['小明', '小红', '团支书']
    ['小明', '小红']
    


```python
# 列表与生成器

a = range(5)            # range()是一个生成器，指向范围
print(a, type(a))       


a = list(range(5))      # range(5)指向的范围是从0到4
print(a)

a = list(range(3,8))     # range(3,8)指向的范围是从3到7
print(a)

a = list(range(3, 8, 2))   # range(3, 8, 2)指向的范围是从3到7步长为2的值
print(a)

  # range(start, stop, step) ，可以指定起始值、终止值、步长； 左闭右开
```

    range(0, 5) <class 'range'>
    [0, 1, 2, 3, 4]
    [3, 4, 5, 6, 7]
    [3, 5, 7]
    


```python
# 小作业
# 1. range()生成的是不是整数   :    是的，经过测试，range()只能生成整数，当有浮点数时会出现TypeError，无法被解释为整数

# 2. 哪种方式书写正确：range(5), range(4:8), range(4, 8)         :  range(4:8) 错误，语法错误

# 3. m = range(10), m[2], m[5], m[-1]分别是多少？      ： 有意思，不需要转为列表，range作为一个范围，本身可以用索引来指向
m = range(10)
print(m[0], m[2], m[5], m[-1])
```

    0 2 5 9
    3
    


```python
# 列表常用操作——添加元素，在列表本身做的变动
lst = [3, 5, 9]
a = 10
b = [2, 'a', 'b']
lst.append(a)
lst.append(b)
print(lst)
  # append()方法，将变量的值存储到列表，变量是什么类型，则原样存储。
    
lst2 = [3, 5, 9]
c = [2, 'a', 'b']
lst2.extend(c)
print(lst2)
  # extend()方法，当变量是可迭代的数据类型时，依次将里面的元素存储到列表

lst3 = [1, 2, 3]
d = '909d'
lst3.extend(d)
print(lst3)

e = [(4, 5, 6), 7, 8]
lst3.extend(e)
print(lst3)
```

    [3, 5, 9, 10, [2, 'a', 'b']]
    [3, 5, 9, 2, 'a', 'b']
    [1, 2, 3, '9', '0', '9', 'd']
    [1, 2, 3, '9', '0', '9', 'd', (4, 5, 6), 7, 8]
    


```python
# 列表常用操作——删除元素
lst = list(range(10))
print(lst)

lst.remove(7)   # remove()方法删除列表中的单个元素
print(lst)

lst.pop(5)      # pop()方法删除索引指向的元素，当不指定索引时，删除最后一个元素；lst.pop(5)本身返回被删除的元素
print(lst)

del lst[0:5]    # del语句，可以删除列表中索引指向的元素
print(lst)

del lst[0::2]   # 切片功能包括步长都适用
print(lst)

lst.clear()     # clear()方法，清空列表元素
print(lst)
```

    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    [0, 1, 2, 3, 4, 5, 6, 8, 9]
    [0, 1, 2, 3, 4, 6, 8, 9]
    [6, 8, 9]
    [8]
    []
    


```python
# 列表常用操作——插入元素
lst = list(range(10))
print(lst)
lst.insert(2, 2.222)      # insert(i,m)方法有2个参数，index和value。
print(lst)

lst.insert(0, 'm')
a = ['a', 'b', 'c']
lst.insert(-1, a)       # 有意思的是，插入就像插队，往前插，所以插入的元素在指定索引对应的元素之前
print(lst)
```

    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    [0, 1, 2.222, 2, 3, 4, 5, 6, 7, 8, 9]
    ['m', 0, 1, 2.222, 2, 3, 4, 5, 6, 7, 8, ['a', 'b', 'c'], 9]
    


```python
# 列表常用操作——复制
x = list(range(5))
m = x
print(x, m)
x[3] = 100         # 当x改变时， m也随之改变
print(x, m)

'''
为什么？？？
在序列及通用操作里，讲过动态变量，同时也讲了序列中是如何指向对象的。
m = x， m 和 x 都是通过同一组索引来指向对象，当x[3]=100时，索引3指向的对象就变成了100，而m也是用的这个索引，所以m[3]也指向了100
'''
# 而copy()方法让m复制了x的元素，但是生成新的索引成为新的列表
x = list(range(5))
m = x.copy()
print(x, m, sep=' || ')
x[0] = 'a'
print(x, m, sep=' || ')
```

    [0, 1, 2, 3, 4] [0, 1, 2, 3, 4]
    [0, 1, 2, 100, 4] [0, 1, 2, 100, 4]
    [0, 1, 2, 3, 4] || [0, 1, 2, 3, 4]
    ['a', 1, 2, 3, 4] || [0, 1, 2, 3, 4]
    


```python
# 列表常用操作——排序
lst = [1, 0, 99, 23, 8, 2]
lst2 = ['dlsd', 'akdl', 'skd', 'sakd']
lst.sort()
lst2.sort()
print(lst, lst2, sep='\n')
   # sort()方法，默认正序排序，即从小到大。
   
print('-'*20)
lst = [1, 0, 99, 23, 8, 2]
lst.sort(reverse=True)        # 倒序排序
print(lst)

print('-'*20)
lst = [1, 0, 99, 23, 8, 2]
lst3 = sorted(lst)
lst4 = sorted(lst, reverse=True)      # 倒序
print(lst3, lst4, sep='\n')
   # sorted()函数，默认正序，排序并复制生成新的列表
```

    [0, 1, 2, 8, 23, 99]
    ['akdl', 'dlsd', 'sakd', 'skd']
    --------------------
    [99, 23, 8, 2, 1, 0]
    --------------------
    [0, 1, 2, 8, 23, 99]
    [99, 23, 8, 2, 1, 0]
    


```python
# 补充元组，元组其实可以看作是不可变的列表

tup1 = (1, 2, 3, 4)
tup2 = 3, 9, 'a', 'b'            # 元组可以这样写，只要了解就好，我们书写的时候还是要按照常规的完整写法
tup3 = (2, )                    # 元组只有一个元素时，要在后加个逗号
print(tup1, tup2, tup3, sep='\n')

tup4 = (2)                     # 当然，不加逗号不会出现语法等错误，只是不是元组类型
print(tup4, type(tup4))

# 因为元组不可变，因此不能添加、删除、插入元素
del tup4        # 当然如果想要删除元组，可以用del语句；同样列表也可以这样删除

# 元组作为序列，自然也有连接、复制、索引以及切片功能，以及序列的内置全局函数同样适用

x = tuple(range(4))
print(x)
  # 转换为元组类型
```

    (1, 2, 3, 4)
    (3, 9, 'a', 'b')
    (2,)
    2 <class 'int'>
    (0, 1, 2, 3)
    


```python
# 小作业
# 1. 分别用append和extend方法给一个序列增加一个元素1
a = [3, 5, 9]
a.append(1)
a.extend([1])
print(a)
print('-'*20)
# 2. x.append([1, 2, 3])和x.extend([1, 2, 3])的区别    : 前者是将[1, 2, 3]作为一个元素添加进x；后者是将[1, 2, 3]中的元素分别添加进x

# 3. 创建一个列表，在列表中插入一个值
b = [3, '22', 9, 'hello']
b.insert(3, 18)
print(b)
print('-'*20)

# 4. 创建一个随机数值列表，按照降序排列
c = [29, 0, 2, 200, 213, 7, 12, 69]
d = sorted(c, reverse=True)
c.sort(reverse=True)
print(d, c, sep='\n')
print('-'*20)

# 5. sort()和sorted()的区别     : sort()是一个方法，使用时必须先调用支持该方法的函数，sorted()是函数

# 6. s = [32, 45, 12, 45, 89, 77], s.remove(45), del s[2], s.pop(4) 有什么区别
s = [32, 45, 12, 45, 89, 77]
s.remove(45)            # 删除第一个目标元素
print(s)

s = [32, 45, 12, 45, 89, 77]
del s[2]               # 删除索引2指向的对象，即第三个元素；不指定索引或切片，则删除整个列表
print(s)

s = [32, 45, 12, 45, 89, 77]
s.pop(4)               # 删除索引4指向的对象，即第五个元素
print(s)
s.pop()           # 不指定索引时， 默认删除最后一个元素；不能使用切片功能
print(s)
print('-'*20)

# 7. m = [4, 5, 6, 73, 4, 4, 4, 4, 2]删除2， 删除所有的4
m = [4, 5, 6, 73, 4, 4, 4, 4, 2]
# 删除2
m.remove(2)   # 因为列表中2只有一个，可以使用remove()
print(m)

m = [4, 5, 6, 73, 4, 4, 4, 4, 2]
m.pop()
print(m)

m = [4, 5, 6, 73, 4, 4, 4, 4, 2]
del m[-1]
print(m)
print('-'*10)

# 删除所有的4
m = [4, 5, 6, 73, 4, 4, 4, 4, 2]
m.sort()
# print(m)
del m[1:6]
print(m)
```

    [3, 5, 9, 1, 1]
    --------------------
    [3, '22', 9, 18, 'hello']
    --------------------
    [213, 200, 69, 29, 12, 7, 2, 0]
    [213, 200, 69, 29, 12, 7, 2, 0]
    --------------------
    [32, 12, 45, 89, 77]
    [32, 45, 45, 89, 77]
    [32, 45, 12, 45, 77]
    [32, 45, 12, 45]
    --------------------
    [4, 5, 6, 73, 4, 4, 4, 4]
    [4, 5, 6, 73, 4, 4, 4, 4]
    [4, 5, 6, 73, 4, 4, 4, 4]
    ----------
    [2, 5, 6, 73]
    


```python
# 关于上面第7题，删除所有的4和2，发现很多解法，很有意思：
'''
总结下面方法的思路
1，将要保留的元素添加到新的列表
2，复制或提取原来的列表，生成一个元素相同的新列表，遍历新列表，删除原列表
3，计数要删除的元素个数，循环这么多次来删除元素。
'''

m = [4, 5, 6, 73, 4, 4, 4, 4, 2]
n = []                                # 思路是建一个新的列表，将不是4和2的元素添加进去，输出新的列表。
for i in m:
    if i != 4 and i != 2:
        n.append(i)
print(n)

m = [4, 5, 6, 73, 4, 4, 4, 4, 2]
m = [i for i in m if i !=4 and i !=2]         # 列表推导式，思路和上面一样，将其他元素添加到新的列表
print(m)

m = [4, 5, 6, 73, 4, 4, 4, 4, 2]
n = m.copy()                               # 思路是复制原列表，遍历新列表来删除原列表元素，这样索引就不会因为元素删除而改变
for i in n:
    if i == 4:
        m.remove(4)
    elif i == 2:
        m.remove(2)
    else:
        continue
print(m)


m = [4, 5, 6, 73, 4, 4, 4, 4, 2]
for i in m[:]:                          # 和上面的原理是一样的，m[:]以切片提取之后，实际上相当于一个新的列表，可以查看它们的id，是不同的
    if i == 4:
        m.remove(4)
    elif i == 2:
        m.remove(2)
    else:
        continue
print(m)
print(id(m), id(m[:]))


m = [4, 5, 6, 73, 4, 4, 4, 4, 2]
c = m.count(4)                              # 这个也很有意思，统计出4的次数，只循环这么多次，每次删掉一个4
for i in range(c):
    m.remove(4)
m.remove(2)
print(m)


m = [4, 5, 6, 73, 4, 4, 4, 4, 2, 3, 2, 2]
c1 = m.count(4)                            # 当2也有多个的时候，也可以用双重循环来删除
c2 = m.count(2)
j = 0
for i in range(c1):
    m.remove(4)
    while j < c2:
        m.remove(2)
        j += 1
print(m)

```

    [5, 6, 73]
    [5, 6, 73]
    [5, 6, 73]
    [5, 6, 73]
    12920632 17254240
    [5, 6, 73]
    [5, 6, 73, 3]
    [2, 2, 2, 2, 3, 4, 4, 4, 4, 4, 5, 6, 73]
    1 5
    [3, 5, 6, 73]
    
